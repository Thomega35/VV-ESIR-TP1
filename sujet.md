# Practical Session #1: Introduction
## Thomas Delapart Kilian Cornec

1. Find in news sources a general public article reporting the discovery of a software bug. Describe the bug. If possible, say whether the bug is local or global and describe the failure that manifested its presence. Explain the repercussions of the bug for clients/consumers and the company or entity behind the faulty program. Speculate whether, in your opinion, testing the right scenario would have helped to discover the fault.

2. Apache Commons projects are known for the quality of their code and development practices. They use dedicated issue tracking systems to discuss and follow the evolution of bugs and new features. The following link https://issues.apache.org/jira/projects/COLLECTIONS/issues/COLLECTIONS-794?filter=doneissues points to the issues considered as solved for the Apache Commons Collections project. Among those issues find one that corresponds to a bug that has been solved. Classify the bug as local or global. Explain the bug and the solution. Did the contributors of the project add new tests to ensure that the bug is detected if it reappears in the future?

3. Netflix is famous, among other things we love, for the popularization of *Chaos Engineering*, a fault-tolerance verification technique. The company has implemented protocols to test their entire system in production by simulating faults such as a server shutdown. During these experiments they evaluate the system's capabilities of delivering content under different conditions. The technique was described in [a paper](https://arxiv.org/ftp/arxiv/papers/1702/1702.05843.pdf) published in 2016. Read the paper and briefly explain what are the concrete experiments they perform, what are the requirements for these experiments, what are the variables they observe and what are the main results they obtained. Is Netflix the only company performing these experiments? Speculate how these experiments could be carried in other organizations in terms of the kind of experiment that could be performed and the system variables to observe during the experiments.

4. [WebAssembly](https://webassembly.org/) has become the fourth official language supported by web browsers. The language was born from a joint effort of the major players in the Web. Its creators presented their design decisions and the formal specification in [a scientific paper](https://people.mpi-sws.org/~rossberg/papers/Haas,%20Rossberg,%20Schuff,%20Titzer,%20Gohman,%20Wagner,%20Zakai,%20Bastien,%20Holman%20-%20Bringing%20the%20Web%20up%20to%20Speed%20with%20WebAssembly.pdf) published in 2018. The goal of the language is to be a low level, safe and portable compilation target for the Web and other embedding environments. The authors say that it is the first industrial strength language designed with formal semantics from the start. This evidences the feasibility of constructive approaches in this area. Read the paper and explain what are the main advantages of having a formal specification for WebAssembly. In your opinion, does this mean that WebAssembly implementations should not be tested? 

5.  Shortly after the appearance of WebAssembly another paper proposed a mechanized specification of the language using Isabelle. The paper can be consulted here: https://www.cl.cam.ac.uk/~caw77/papers/mechanising-and-verifying-the-webassembly-specification.pdf. This mechanized specification complements the first formalization attempt from the paper. According to the author of this second paper, what are the main advantages of the mechanized specification? Did it help improving the original formal specification of the language? What other artifacts were derived from this mechanized specification? How did the author verify the specification? Does this new specification removes the need for testing?

## Answers

1. In 1998 a space probe called Mars Climate Orbiter was launched. Its goal was to study Mars planet. Unfortunately, due to a bug, this probe did not reach its goal. This bug was triggered by a unit confusion. Let's explain in details this bug. The software of the probe worked with the Anglo-Saxon units of measurement (Pound-force) while the software of the navigation system worked with the metric system. The difference between these two measurement unit is a factor 10.
Because of that bug the probe has passed at 57km from Mars and because of Mars atmosphere and the speed the probe was destroyed. So because of this silly bug, all the mission failed.
But who is responsible for ? It is not easy to say. The NASA engineers asked the subcontractors to use metric system for the values. But Lockheed developed the code with Anglo-Saxon  units and NASA engineers, thinking that the contact was well respected, did not check this parameter. The fault is shared by both actors. In one hand Lockheed did not respect specifications and in another hand NASA did not check.
Now we can ask : Would better tests have prevented that?
For Lockheed part, better tests would not have prevented this error because this "better tests" would have made with Anglo-Saxon units. However, if NASA had done better tests on results, then they might not have had this bug.

2. [The CollectionUtils.removeAll method calls the ListUtils.retainAll method instead of the ListUtils.removeAll method.](https://issues.apache.org/jira/projects/COLLECTIONS/issues/COLLECTIONS-219?filter=allissues) The COLLECTIONS-219 was a bug in the version 3.2.1 that was solved in the version 4.0 of the project. The bug was a local bug that was caused by a wrong implementation of the method `public static Collection removeAll(Collection collection, Collection remove)`. The method was supposed to remove all the elements of the collection `remove` from the collection `collection`. However, the implementation was wrong, and the method was calling the method `retainAll` instead of `removeAll`. The solution was to replace the call to `retainAll` by a call to `removeAll`. The bug being a typo, no test was added to ensure that the bug would not reappear in the future.

3. Netflix performs experiences like randomly select vm instances which are working and shut them down, or they simulate error between Netflix service and check if "the system degrades gracefully". To assure that these tests do not make fail services, they perform them only during working hour. The result of these tests is a service which is available even during time with issue. But Netflix is not the only company who perform these types of experiments. To finish with, Chaos Engineering could be used in company who has to delivered very sensitive project like nuclear one for example. Indeed, it's easily understanding that the slightest error could have terrible effects.

4. WebAssembly defines a portable binary-code format for executable programs, this low-level, safe and portable language has a formal specification. 
The main advantages of having a formal specification are :
- The language's correctness is proved by the formal specification.
- You can use prove your program too by using the formal specification.
- Having a formal specification remove the ambiguity of the language.
- The formal specification is also a good documentation of the language.

However, the formal specification is not enough to ensure that the implementations are correct. Indeed, the formal specification is a mathematical model of the language, and it is not possible to prove that the implementations are correct. So, the implementations should be tested.
   
   
5. The main advantages of mechanized specification are, it is possible to perform formal analysis and verification. Furthermore, it helps to improve the original formal specification because it was not formally specified. Also, it allows deriving of others artifacts like a separate executable interpreter and type checker. To finish with this new specification is enough to pass the WebAssembly test and so to be executed "in the wild".

Despite that, the mechanized specification is a good tool to verify the original formal specification, but it is not enough to ensure that the implementations are correct. Indeed, It is here also not possible to prove that the implementations are correct. So, the implementations should be tested.